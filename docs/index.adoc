= picoCLI - a mighty tiny Command Line Interface
Remko Popma <rpopma@apache.org>
v0.2.0, 2017-02-11
:toc: left
:toclevels: 1
:toc-title: Features

A CLI framework in a single file, designed to be easy to include in your application _in source form_:
allowing you to parse command line arguments without dragging in an external dependency.

How it works: annotate your class and picoCLI initializes it from the command line arguments,
converting the input to strongly typed values in the fields of your class. Any parameter prefix style works,
with special support for POSIX-style clustered short options.
Easily customizable online "usage" help. Can be configured to make parameter matching case-insensitive,
and supports abbreviated options when unambiguous. Works with Java 5 or higher.

== Example

[source,java]
----
import picocli.CommandLine.Parameter;
import picocli.CommandLine.Parameter;
import java.io.File;

public class Example {
    @Parameter(description = "Specifies the input file(s).")
    private File[] inputFiles;

    @Parameter(names = { "--out", "-o" }, description = "Specifies the output file.", required = true)
    private File outputFile;

    @Parameter(names = { "--verbose", "-v" }, description = "Be verbose.")
    private boolean verbose = false;

    @Parameter(names = { "--help", "-h" }, help = true, description = "Displays this help message and quits.")
    private boolean helpRequested = false;
    ...
}
----

Then invoke `CommandLine.parse` with the command line arguments and an object you want to initialize.

[source,java]
----
Example app = new Example();
CommandLine.parse(app, "--out", "path/to/outputFile", "inputFile1", "inputFile2");
assert app.inputFiles != null;
----

== Named Options and Positional Parameters
Imagine an application that takes some input files and compresses them to an output file.
----
Compress -o outputFile file1 file2 file3
----
The program takes one option (`-o`, the output file) and one or more input files. One way to accomplish this with picoCLI looks like this:

[source, java]
----
import picocli.CommandLine.*;
import java.io.File;

@Usage(programName = "Compress", header = "Compresses the specified input files to an output file")
public class Compress {
    @Parameter(arity = "1..*", usage = "one or more files to compress")
    File[] inputFiles;

    @Parameter(names = {"-o", "--outfile"}, usage = "optional output file name. If omitted directory name is used.")
    File outputFile;

    @Parameter(names = {"-h", "--help"}, help = true, usage = "display this help message")
    boolean helpRequested;

    public static void main(String... args) {
        try {
            Compress compress = CommandLine.parse(new Compress(), args);
            if (compress.helpRequested) {
                CommandLine.usage(compress, System.err);
                return;
            }
            doCompress();
        } catch (ParseException ex) {
            System.err.println(ex.getMessage());
            CommandLine.usage(compress, System.err);
        }
    }

    private void doCompress() { ... } // business logic of the application
}
----

== Command Line Flags and Switches
Boolean options don't need a parameter. If the option name is specified on the command line, the corresponding field is set to `true`:

[source, java]
----
class MyProgram {
    @Parameter(names = { "-v", "--verbose" }, description = "Verbose mode")
    boolean verbose;
}
----

The boolean field `verbose` will have value `true` when the program is invoked with the "-v" option:
----
CommandLine.parse(new MyProgram(), { "-v", "arg1", "arg2" });
----

=== Explicit Boolean Parameters
It is possible to explicitly specify "true" or "false" as a parameter for a boolean option by defining an explicit <<Arity: Minimum and Maximum Number of Parameters,`arity`>> attribute. A boolean option with `arity = "0..1"` accepts zero to one parameter, `arity = "1"` means the option _must_ have one parameter. For example:

[source, java]
----
class MyProgram {
    @Parameter(names = "-x", arity = "1", description = "boolean option with 1 mandatory parameter")
    boolean x;

    @Parameter(names = "-y", arity = "0..1", description = "boolean option with minimum 0 and maximum 1 parameter")
    boolean y;
}
----

The following ways to invoke the program will be accepted (values are not case sensitive):
----
<main> -x true
<main> -x FALSE
<main> -x TRUE -y
<main> -x True -y False
----

But trying to specify the `-x` option without a parameter, or with a value other than "true" or "false" (case insensitive) will result in a `ParameterException`.

== Arity: Minimum and Maximum Number of Parameters
Option fields of type array or `List` (or any class extending `Collection`) will be able to hold multiple values. The `arity` attribute can be used to specify the exact number of required parameters, or a range with a minimum and a maximum number of parameters. The maximum can be a fixed number, or can be `"*"` to denote "any number" of parameters. For example:
[source, java]
----
class MyProgram {
    @Parameter(arity = "3", descriptions = "exactly three Files")
    File[] files;

    @Parameter(names = "-f", arity = "2..4", description = "two to four floating point numbers")
    double[] doubles;

    @Parameter(names = "-s", arity = "1..*", description = "at least one string")
    String[] strings;
}
----
A `MissingParameterException` is thrown when fewer than the miminum number of required parameters is specified as command line arguments. Options with an exact number or an exact range will consume up to the maximum number of parameters.

=== Auto-detect New Options
Once the minimum number of parameters is consumed, picoCLI will check for each subsequent command line argument whether it is another option, or a new parameter. For example:

----
<main> -s A B C -f 1.0 2.0 3.0
----
The above command line arguments will be parsed as three parameters for the `-s` option, followed by three parameters for the `-f` option.

=== Ambiguous Input
Positional parameters do not have an option name, and the below example command line arguments will be parsed as six parameters for the `-s` option, not as three strings and three files:
----
<main> -s A B C file1 file2 file3
----

Users can disambiguate the input by specifying a double dash (`--`) after the option parameters.
The argument `--` is interpreted as a delimiter indicating the end of options. Any following arguments are treated as positional option. For example, the following command line arguments will be parsed as three strings and three files:
----
<main> -s A B C -- file1 file2 file3
----

== Default Arity: Number of Parameters Depends on Option Type
Most of the time options don't need to define their arity explicitly. When the arity is not specified, the implicit arity of the option depends on the field's type:

* Boolean fields: `"0"`. By default no option are required or expected.
* Single-valued types (primitive fields, Number fields, String, File etc): `"1"`. By default option fields with these types expect a single value.
* Multi-valued types (arrays or classes extending `Collection`): `"0..*"`. By default option fields with this type have no mandatory parameters but accept any number of parameters.

== Required Options
Options can be marked `required` to make it mandatory for the user to specify them on the command line. When a required option is not specified, a `MissingParameterException` is thrown from the `parse` method. For example:
[source, java]
----
class MyProgram {
    @Parameter(arity = "3", descriptions = "exactly three Files")
    File[] files;

    @Parameter(names = "-x", description = "optional switch")
    boolean x;

    @Parameter(names = "-y", required = true, description = "mandatory switch")
    boolean y;

    @Parameter(names = "-n", required = true, description = "mandatory number")
    int number;
}
----
The following command line arguments would result in an exception complaining that `y` and `number` are missing:
----
CommandLine.parse(new MyProgram(), "-x file1 file2 file3")
----
The following command line arguments would be accepted:
----
CommandLine.parse(new MyProgram(), "-x -y -n 123 file1 file2 file3")
----


// TODO document that if arity>1 and args="-opt=val1 val2", arity overrules the "=": both values are assigned


== Options with Parameters
== Parameters are strongly typed
== built-in type converters

Converters for byte, short, int and long (and their wrapper classes) use the https://docs.oracle.com/javase/7/docs/api/java/lang/Integer.html#decode(java.lang.String)[`decode`] method to convert String values, so you can specify hexadecimal and even octal values in additional to the normal decimal values. (Be aware that values starting with `0` are interpreted to be octal values!)

== registering custom type converters
== option short form

== Clustered Short Options
Single-character options preceded with a '-', like `-v` or `-r`, can be grouped, so `-vxr` is equivalent to `-v -x -r`.

// TODO ambiguous short options: ambiguity with the -f FILE and -fFILE notation.
// TODO ambiguous options: writing --input ARG (as opposed to --input=ARG) is ambiguous,


== Download

NOTE: Here is the source. Copy and paste it into a file called `CommandLine.java`, add it to your project, and enjoy!

[source,java]
----
include::../src/main/java/picocli/CommandLine.java[]
----